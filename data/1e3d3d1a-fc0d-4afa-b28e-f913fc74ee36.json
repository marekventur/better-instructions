{
  "id": "1e3d3d1a-fc0d-4afa-b28e-f913fc74ee36",
  "instruction": "Write a function in Python that evaluates a given expression.",
  "input": "",
  "output": "def evaluate_expression(expression): \n      \n    # a stack to store integer values \n    values = [] \n  \n    # a stack to store operators. \n    ops = [] \n    i = 0\n      \n    while i < len(expression): \n          \n        # Current token is a whitespace, \n        # skip it. \n        if expression[i] == ' ': \n            i += 1\n            continue\n              \n        # Current token is an opening  \n        # brace, push it to 'ops' \n        elif expression[i] == '(': \n            ops.append(expression[i]) \n              \n        # Current token is a number, push  \n        # it to stack for numbers. \n        elif expression[i].isdigit(): \n            val = 0\n              \n            # There may be more than one \n            # digits in the number. \n            while (i < len(expression) and\n                expression[i].isdigit()): \n                  \n                val = (val * 10) + int(expression[i]) \n                i += 1\n                  \n            values.append(val) \n  \n        # Closing brace encountered, solve  \n        # entire brace. \n        elif expression[i] == ')': \n              \n            while len(ops) != 0 and ops[-1] != '(': \n                  \n                val2 = values.pop() \n                val1 = values.pop() \n                op = ops.pop() \n                  \n                values.append(performOp(val1, val2, op)) \n              \n            # pop opening brace. \n            ops.pop() \n              \n        # Current token is an operator. \n        else: \n              \n            # While top of 'ops' has same or  \n            # greater precedence to current \n            # token, which is an operator. \n            # Apply operator on top of 'ops'  \n            # to top two elements in values stack. \n            while (len(ops) != 0 and\n                precedence(ops[-1]) >= precedence(expression[i])): \n                  \n                val2 = values.pop() \n                val1 = values.pop() \n                op = ops.pop() \n                  \n                values.append(performOp(val1, val2, op)) \n                  \n            # Push current token to 'ops'. \n            ops.append(expression[i]) \n          \n        i += 1\n          \n     # Entire expression has been parsed at this  \n    # point, apply remaining ops to remaining \n    # values. \n    while len(ops) != 0: \n          \n        val2 = values.pop() \n        val1 = values.pop() \n        op = ops.pop() \n          \n        values.append(performOp(val1, val2, op)) \n      \n    # Top of 'values' contains result, return it. \n    return values[-1]",
  "license": "stanford-alpaca-unknown",
  "generation-type": "openai-text-davinci-003",
  "generation-reference": "https://github.com/tatsu-lab/stanford_alpaca/blob/main/alpaca_data.json",
  "modified": [],
  "verified": [],
  "tags": []
}